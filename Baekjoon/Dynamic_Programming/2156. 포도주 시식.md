> # [2156. 포도주 시식][link]
[link]: https://www.acmicpc.net/problem/2156

먼저 규칙에서 3잔을 연속으로 마실 수 없으므로  
3잔을 기준으로 생각을 해보자  

3잔을 기준으로 했을때 크게 두가지로  
3번째 잔을 안 마셨을때와 마셨을때로 나뉠수 있다.

3번째 잔을 안마셨을때를 생각해보자면  
( O : 마셨을 경우 X : 안 마셨을경우)  

    1. O O X  
    2. O X X  
    3. X O X  
    4. X X X  
총 4가지의 경우의 수가 나온다.  

다만, 위에 경우의 수를 살펴보면 1잔만 마시거나 아에 마시지 않는경우는  
절대로 2잔을 마셨을 경우보다 무조건 더 많을 수가 없다.  
왜냐하면 3번째잔 이후에 4번째잔을 마시던 마시지 않던 규칙에 위배되지 않기 때문이다.  

결국 3번째 잔을 마시지 않을 경우에는 1번째 잔, 2번째잔을 마셨을때가 가장 많다..!  

즉, N번째까지 왔을때, N번째 잔을 마시지 않는다면 이 때 마실수 있는 포도주의 양은   
최대 N-1번째 잔까지 왔을때 이다.

이것을 식으로 나타낸다면 다음과 같다.
``` c++
    dp[N] = dp[n-1];
```

다음으로 3번째 잔을 마셨을 경우를 생각해보자.  
이때는 앞의 여러 잔을 이미 마셨다고 가정해보자. 

    1. ? ? ? ? ? ? ? ? O X O
    2. ? ? ? ? ? ? ? ? X O O
    3. ? ? ? ? ? ? ? ? X X O

총 3가지의 경우의 수가 나온다.  

다만, 3번째 잔을 안마셨을때와 같이 3번째 경우의 수는 1번째 경우의 수와,  
2번째 경우의 수보다  무조건 많이 마실수 가 없다.  

이 또한, 앞에서 포도주를 얼마나 마셨던간에 뒤에 3잔을 어떻게 마시냐에 따라서  
최대로 마실 수 있는 포도주의 양이 결정 되기 때문에 당연히 3잔중 2잔을 마시는 것이 제일 많은것 이다.  

최종적으로 경우의 수가 두가지 이기 때문에 대소 비교를 하여 제일 큰 수를 선택하면 된다.
  
이제 이것 또한 식으로 나타내보자.
``` c++
    dp[N] = MAX(dp[N-3] + grape[N-2] + grape[N], dp[N-1] + grape[N]);
```
위 식에서 처음으로 나타낸 식까지 넣어주면 다음과 같다.
``` c++
    dp[N] = MAX(dp[N-3] + grape[N-2] + grape[N], dp[N-2] + grape[N], dp[N-1]);
```

  
  마지막으로 아래는 소스코드

```c++
    #include <iostream>

    using namespace std;

    int MAX(int, int, int);

    int main() {

    	int grape[10001] = { 0, };
    	int dp[10001] = { 0, };

    	int count = 0;

    	cin >> count;

    	for (int i = 1; i <= count; i++)
    	{
    		cin >> grape[i];
    	}

    	dp[1] = grape[1];
    	dp[2] = dp[1] + grape[2];

    	for (int i = 3; i <= count; i++)
    	{
    		dp[i] = MAX(dp[i - 3] + grape[i - 1] + grape[i], dp[i - 2] + grape[i], dp[i - 1]);
    	}

    	cout << dp[count];

    	return 0;
    }

    int MAX(int a, int b, int c) {

    	int temp = a > b ? a : b;
    	return temp = c > temp ? c : temp;
    }
```
